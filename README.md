### 项目概述

本项目是一个实时抽奖系统，商家可以在系统中发布抽奖，用户在时限内点击参与抽奖并实时显示获奖结果，在后台管理中能查看所有抽奖项目。

### 技术栈

go1.15，Gin 1.6.3，gorm 1.9.16，MySQL 8.0，Redis，RabbitMQ

### 功能介绍

商家：注册，登录，发布抽奖，查看抽奖实时统计

用户：注册，登录，参与抽奖，查看中奖结果

管理员：登录，查看所有抽奖信息

### 系统功能实现

#### 数据模型Model与数据库连接MySQL Driver

总共五个数据模型，admin、business、customer创建三类使用者信息表，lottery存放抽奖信息，lotteryQueueObject则用于抽奖队列中表示该位的中奖信息。

使用gorm操作MySQL数据库

#### 路由信息Router与中间件Middleware

用户：公共主页、用户登录页面、用户注册页面、用户主页、可参与的抽奖页面、参与抽奖

商家：公共主页、商家登录页面、商家注册页面、商家主页、已创建的抽奖页面、创建新的抽奖

管理员：公共主页、管理员登录页面、管理员主页、任意抽奖页面

使用中间件来进行页面访问权限认证

#### 处理程序Handler与前端页面Templates

对于每个路由实现对应的Handler，实现业务逻辑后渲染前端tmpl模板输出，以商家创建抽奖以及用户参与抽奖两个核心功能为例：

##### 商家创建抽奖

1. 校验数据合法性，若不合法则返回创建抽奖页面并提示错误信息
2. 校验businessToken，验证是否有创建抽奖的资格
3. 调用lottery.Create()，根据表单信息创建抽奖
4. 校验数据合法性，创建抽奖并调用lottery.CreateLotteryQueue()创建抽奖队列
5. 抽奖队列根据预计抽奖规模和奖品列表，提前生成结果列表，然后利用洗牌算法将其打乱，然后生成一个抽奖队列的表，表名用lotteryId标识，将预生成的结果写入该表，用于用户抽奖时查询。

##### 用户参与抽奖

1. 从request中获取想要参与抽奖的customer以及抽奖的lottery信息
2. 校验customer是否有抽奖权限以及是否已经参与过此次抽奖，如果没有权限直接返回用户主页
3. 如果已经参与过此次抽奖，则直接进入抽奖页面，抽奖页面将会刷新显示本次抽奖的信息
4. 如果未参加过此次抽奖，则调用函数customer.JoinLottery(lotteryId)，参加此次抽奖
5. 调用lottery.Gift()抽取奖品，并将中奖信息写入customer以及lottery
6. lottery.Gift()将参与中奖人数加1，然后从抽奖队列中以参与中奖人数为索引查询对应的中奖信息

抽奖队列作为核心，在商家创建时生成，在抽奖结束后销毁。

lottery State信息的改变以及抽奖队列的销毁由中间件控制，在管理员/商家/用户访问抽奖页面时，都会检测对应的lottery State信息，弱需要改变，则会进行改变，保证各使用者访问时数据的正确性。

### 性能优化策略及实现

1. 提前生成抽奖队列，减少实时抽奖中性能开销
2. 使用redis数据库，将抽奖队列存入redis缓存数据库，加快IO速度
3. 使用RabbitMQ消息队列，提升并发性能。用户参与抽奖时先改变参与抽奖的总数信息以及自己参与抽奖的信息，防止奖品重复发放以及某用户多次参与抽奖，然后将订单消息发送至消息队列，消费时才执行其余复杂逻辑。
4. 在抽奖快开始时通过前端js代码帮助用户刷新，提高使用体验

### 应用安全策略及实现

1. 使用[github.com/unrolled/secure](http://github.com/unrolled/secure)中间件，为Golang/Gin框架添加对HTTPS的支持，实现报文信息加密。

2. 由于功能较少，没有使用严格的RBAC模型，利用cookie存储jwt-Token实现登录身份认证的中间件。在登录时，生成一个包含用户id信息的token，并设置过期时间，在需要身份认证的界面通过中间件验证token，在用户注销时，删除token。

登录时创建token

3. 在前端添加js代码实现数据合法性校验，并在后端也实现数据合法性校验，防止SQL注入、XSS等常见漏洞。

4. （未实现）在表单中加入CSRF-token，使表单不可预测，防止CSRF类攻击。

### 仓库地址

